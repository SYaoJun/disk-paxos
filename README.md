# Disk Paxos
- [Disk Paxos](#Disk-Paxos)
  - [1 介绍](#1-介绍)
  - [2 状态机方法](#2-状态机方法)
  - [3 算法非正式描述](#3-算法非正式描述)
  - [4 总结](#4-总结)
## 1 介绍
故障容错需要冗余组件。在系统分区的情况下保持一致性使得如果任一组件失败，则两个组件系统无法取得进展。有无数的容错算法用于实现分布式系统，但我们所知的所有算法都将组件等同于处理器。但是，还有其他类型的组件可以进行复制。特别是，现代网络现在可以包括磁盘驱动器作为独立组件。由于商品磁盘比计算机更便宜，因此将它们用作实现容错的复制组件非常具有吸引力。商品磁盘与处理器不同之处在于它们不可编程，因此我们不能只是在现有算法中将磁盘替换为处理器。

我们在这里提出了一种名为Disk Paxos的算法，用于实现一个具有处理器和磁盘网络的任意容错系统。它在任意数量的非拜占庭故障发生时保持一致性。也就是说，处理器可能暂停任意长的时间，可能完全失败，并且可能在失败后重新启动，只记得自己已经失败；磁盘可能对某些或所有处理器不可访问，但不能损坏。Disk Paxos保证了如果系统稳定且至少有一个非故障处理器可以读写大多数磁盘，则系统将取得进展。稳定性意味着每个处理器要么不故障，要么已完全失败，并且非故障处理器可以访问非故障磁盘。例如，它允许由两个处理器和三个磁盘组成的系统在任一处理器和任一磁盘故障后继续取得进展。

Disk Paxos是经典Paxos算法的一个变体，它是一个简单、高效的算法，已经在实际分布式系统中使用过。经典Paxos可以看作是Disk Paxos的一种实现，其中每个处理器都有一个磁盘，并且只能由其处理器直接访问磁盘。

在下一节中，我们回顾了将实现任意分布式系统的问题简化为共识问题的方法。第3节非正式地描述了Disk Paxos使用的共识算法Disk Synod。它包括一个不完整正确性证明的草图，并解释了Disk Synod与经典Paxos的Synod协议之间的关系。第4节简要讨论了一些实现细节，并包含了常规的结论性的备注。附录提供了共识问题和Disk Synod算法的正式规范，并勾勒了严格的正确性证明。

本文的早期版本，附录的简化版本不包含任何证明，先前已经发表过。
## 2 状态机方法

状态机方法是实现任意分布式系统的一种通用方法。该系统被设计为执行一系列命令的确定性状态机，并且一个共识算法确保对于每个n，所有处理器都同意第n个命令。这将将构建任意系统的问题简化为解决共识问题。在共识问题中，每个处理器p从输入值input[p]开始，并且它可以输出一个值。解决方案应该是：非平凡的，任何输出值应该在某个时间点是某个处理器p的输入值input[p]。（如果p失败并重新启动，则input[p]的值可能会更改。）一致的，所有输出值都是相同的。非阻塞的，如果系统稳定且非故障处理器可以与大多数磁盘通信，则处理器最终将输出一个值。长期以来人们已经知道，使用异步消息传递的一致的、非阻塞的共识总是需要至少两个消息延迟。使用较少消息延迟的非阻塞算法不能保证一致性。例如，Isis的组通信算法允许属于当前组的两个处理器在它们都属于的先前组中是否广播了消息上发生分歧。这种算法本身无法保证一致性，因为关于消息是否已广播的分歧可能导致关于输出值的分歧。经典的Paxos算法使用了一个称为Synod算法的三阶段共识协议，其中每个阶段都需要两个消息延迟，第三阶段只是广播输出值。然而，要输出的值直到第二阶段才被选择。当选举产生新领导者时，它只执行一次第一阶段，用于后续所有系统命令的一系列共识算法。只有最后两个阶段是针对每个单独命令分别执行的。在Disk Synod算法中，由Disk Paxos使用的共识算法，每个处理器在每个磁盘上都有一个分配的块。该算法在Disk Paxos中，与经典Paxos一样，没有时间假设；进程可以完全异步。Fischer、Lynch和Paterson的经典结果表明，纯粹的异步非阻塞共识算法是不可能的。因此，必须引入时钟和实时假设。典型的工业方法是使用基于超时的临时算法选举领导者，然后由领导者选择输出。很容易设计出一种当系统稳定时运行的领导选举算法，这意味着它大部分时间都能工作。但很难制定一种在系统不稳定时始终正确工作的算法。经典Paxos和Disk Paxos也假定了用于选举领导者的实时算法。然而，领导者仅用于确保进展。即使有多个领导者，一致性也会得到维护。因此，如果由于网络不稳定而导致领导者选举算法失败，则系统可能无法取得进展；但它不会变得不一致。当系统变得稳定并选出单一领导者时，系统将再次取得进展。
## 3 算法非正式描述
我们现在非正式地描述Disk Synod算法，并解释为什么它有效。我们还讨论了它与经典Paxos的Synod协议之间的关系。请记住，在正常操作中，只有一个领导者会执行该算法。其他处理器什么也不做；它们只是等待领导者告知它们结果。然而，即使在由多个处理器执行或当领导者在宣布结果之前失败并选择了新领导者的情况下，该算法也必须保持一致性。
### 3.1 算法
我们假设每个处理器p从一个输入值input[p]开始。就像Paxos的Synod算法一样，处理器执行一系列编号的选票，选票编号逐渐增加。选票号是一个正整数，并且不同的处理器使用不同的选票号。例如，如果处理器从1到N编号，那么处理器i可以使用选票号i，i + N，i + 2N等。处理器p执行选票分为两个阶段，第一个阶段试图选择一个值，第二个阶段试图提交该值。

在从第一阶段到第二阶段的过渡中发生了值v的选择。当处理器p完成第二阶段时，该值被提交，并可以输出。在任一阶段，如果处理器发现另一个处理器已经开始了一个更高编号的选票，它将中止其选票。在这种情况下，处理器可能会选择一个更高的选票号并开始一个新的选票。（如果它仍然认为自己是领导者，则会这样做。）如果处理器完成第二阶段而没有中止——也就是说，没有发现更高编号的选票——那么值v就会被提交，处理器可以输出它。处理器p在进入第二阶段之前不需要知道input[p]的值，因此可以提前对算法的任意数量的独立实例执行第一阶段。

为了确保一致性，我们必须保证两个不同的值不能成功提交——要么是由不同的处理器提交（因为领导者选举算法尚未成功），要么是由同一处理器在两个不同的选票中提交（因为它失败并重新开始）。为了确保算法是非阻塞的，我们必须保证如果只有一个处理器p在执行，那么p最终会提交一个值。
在实践中，当一个处理器成功提交一个值时，它将在其磁盘块上写入该值已被提交的信息，并将此事实广播给其他处理器。如果一个处理器得知某个值已经被提交，它将中止其选票并简单地输出该值。这个优化显然保持了正确性；我们不会进一步考虑它。
为了执行该算法，处理器p维护一个记录dblock[p]，其中包含以下三个组件：
- mbal：当前的选票号。
- bal：处理器p进入第二阶段的最大选票号。
- inp：处理器p在选票号bal中尝试提交的值。

初始时，bal等于0，inp等于一个特殊值NotAnInput，它不是可能的输入值，而mbal可以是其可能的任意选票号。我们将disk[d][p]定义为处理器p写入dblock[p]的磁盘d中的块。我们假设读取和写入一个块是原子操作。
处理器p执行选票的第1或第2阶段如下。对于每个磁盘d，它首先尝试将dblock[p]写入disk[d][p]，然后对所有其他处理器q读取disk[d][q]。如果对于任何d和q，它发现disk[d][q].mbal > dblock[p].mbal，则中止选票。当p已经写入并读取了大多数磁盘时，不读取任何mbal组件大于dblock[p].mbal的块，阶段就会完成。当它完成第1阶段时，p选择一个新值dblock[p].inp，将dblock[p].bal设置为dblock[p].mbal（其当前选票号），并开始第2阶段。当它完成第2阶段时，p已经提交了dblock[p].inp。

为了完成我们对两个阶段的描述，我们现在描述处理器p如何选择在第2阶段尝试提交的dblock[p].inp的值。让blocksSeen是由dblock[p]和处理器p在第1阶段读取的所有记录disk[d][q]组成的集合。让nonInitBlks是blocksSeen的子集，由那些inp字段不是NotAnInput的记录组成。如果nonInitBlks为空，则p将dblock[p].inp设置为其自己的输入值input[p]。否则，它将dblock[p].inp设置为nonInitBlks中具有最大值bk.bal的某个记录bk的inp。

最后，我们描述处理器p在从故障中恢复时做什么。在这种情况下，p从大多数磁盘d中读取其自己的块disk[d][p]。然后，它将dblock[p]设置为它读取的具有最大值bk.mbal的任何块bk，并通过增加dblock[p].mbal并开始第1阶段来开始一个新的选票。

该算法在图1中非正式地总结了处理器p执行单个选票的过程。处理器通过执行“开始选票”操作开始选票。如果选票中止，或在任何其他时候（除非它已失败，在这种情况下它必须执行“故障后重新启动”操作），它可以开始一个新的选票。算法的精确定义出现在附录中。

### 3.2 算法的有效性
#### 3.2.1 安全性
我们直观地解释了为什么Disk Synod算法满足两个安全属性：非平凡性和一致性。非平凡性是显而易见的，因为任何块的val字段总是被设置为另一个块的val字段。
我们现在解释为什么Disk Synod算法能够保持一致性。首先，我们考虑算法的共享内存版本，该版本使用单写多读的常规寄存器。不是将数据写入磁盘，处理器p将dblock[p]写入共享寄存器；并且从寄存器中读取其他处理器q的dblock[q]的值。处理器选择第二阶段的bal和inp值的方式与之前相同，只是它为每个其他处理器只读取一个dblock值，而不是从每个磁盘读取一个。我们暂时假设处理器不会发生故障。

为了证明一致性，我们必须证明对于任何处理器p和q，如果p完成第二阶段并提交值v_p，q完成第二阶段并提交值v_q，则v_p = v_q。设bp和bq分别是这些值提交的投票编号。不失一般性，我们可以假设bp ≤ bq。此外，通过对bq进行归纳，我们可以假设，如果任何处理器r为投票编号为bp ≤ br < bq的投票br启动了第二阶段，则它的dblock[r]。inp = v_p。

在第二阶段的读取中，p不能看到q在第一阶段写入的dblock[q]。mbal的值，否则p会中止。因此，在第二阶段中，p对dblock[q]的读取未跟随q的第一阶段写入。由于每个阶段的读取都在写入之后，这意味着q对dblock[p]的第一阶段读取必须跟随p的第二阶段写入。因此，q在第一阶段读取了dblock[p]的当前（最终）值——一个具有bal字段bp和inp字段v_p的记录。让bk是q在其第一阶段读取的任何其他块。由于q没有中止，所以bq > bk.mbal。由于对于任何块bk，bk.mbal ≥ bk.bal，这意味着bq > bk.bal。根据归纳假设，我们得到，如果bk.bal ≥ bp，则bk.inp = v_p。由于这对q在第一阶段读取的所有块bk都成立，并且由于q读取了dblock[p]的最终值，该算法意味着q必须将dblock[q]。inp设置为v_p用于第二阶段，证明了v_p = v_q。

为了从共享内存版本获得Disk Synod算法，我们使用了Attiya、Bar-Noy和Dolev的一种技术，即使用网络磁盘实现单写多读寄存器。为了写入一个值，处理器将值与版本号一起写入多数磁盘。要读取，处理器读取多数磁盘并取具有最大版本号的值。由于两个磁盘多数包含至少一个共同的磁盘，读取必须获取要么是完成写入的最后版本，要么是更晚的版本。因此，这实现了一个常规寄存器。通过这种技术，我们将共享内存版本转换为处理器和磁盘网络的版本。实际的Disk Synod算法以两种方式简化了通过这种转换得到的算法。首先，不需要版本号。mbal和bal值起到版本号的作用。其次，处理器p不需要从其从磁盘读取的dblock[q]版本中选择单个版本。因为mbal和bal值不会减小，所以早期版本没有影响。

到目前为止，我们忽略了处理器故障。有一种简单的方法可以扩展共享内存算法以允许处理器故障。处理器通过简单地从其寄存器读取其dblock值并开始一个新的投票来恢复。然后，失败的进程就像是一个处理器随时都可以开始新的投票一样。我们可以证明这个广义版本也是正确的。然而，在实际的磁盘算法中，一个处理器在写入时可能会失败。这可能会使其磁盘块处于尚未写入大多数磁盘的状态。这种状态在共享内存版本中没有对应的状态。似乎没有简单的方法可以从共享内存算法中推导出恢复过程。具有故障的完整Disk Synod算法的证明比简单的共享内存版本的证明要复杂得多。尝试为简单算法提供上面给出的行为证明会导致我们已经学会避免的复杂且容易出错的推理。相反，我们在附录中概述了一个严格的断言证明。
### 3.3 活性
Disk Synod算法的活性（进展）需要领导者选举算法的活性。一个处理器执行Disk Synod算法的步骤当且仅当它相信自己是领导者。我们展示了如果最终一个单一的非故障处理器p，它可以读写大多数磁盘，永远是唯一的领导者，那么一个值将被提交。

假设p是唯一的领导者并且它可以读写大多数磁盘。由于p可以访问大多数磁盘，它执行的每个阶段要么完成，要么中止。只有当p读取一个大于自己的mbal值时，阶段才会中止，当它中止时，p会增加自己的mbal值。由于p是唯一的领导者，只有它写入磁盘。因此，如果p不能完成阶段1和阶段2，那么它的mbal值最终将大于它读取的每个磁盘块的mbal值。因此，p必须最终完成阶段1和阶段2而不会中止，从而提交一个值。
### 3.4 从磁盘 Paxos 派生经典 Paxos
在传统的分布式容错系统观点中，处理器执行操作并维护其状态在本地内存中，使用稳定存储来从故障中恢复。另一种观点是，处理器维护稳定存储的状态，仅使用本地内存来缓存稳定存储的内容。将磁盘与稳定存储进行关联，传统的分布式系统则是一个由处理器和磁盘组成的网络，每个磁盘属于一个单独的处理器；其他处理器只能通过向其所有者发送消息来读取磁盘。

现在让我们考虑如何在每个处理器都有自己的磁盘的处理器网络上实现Disk Synod。为了执行阶段1或2，处理器p将通过向磁盘d的所有者q发送包含dblock[p]的消息来访问磁盘d。处理器q可以将dblock[p]写入disk[d][p]，读取所有r = p的disk[d][r]，并将其读取的值发送回p。然而，仔细检查Disk Synod算法揭示了没有必要发送回所有这些数据。p所需要的只是（i）知道它的mbal字段是否大于任何其他块的mbal字段，如果是，（ii）具有最大bal字段的块的bal和inp字段。因此，q只需要在磁盘上存储三个值：具有最大bal字段的块的bal和inp字段，以及所有磁盘块的最大mbal字段。当然，q会在其内存中缓存这些值，因此只有当这些值中的任何一个发生变化时，才会实际写入磁盘。

处理器还必须读取其自己的磁盘块以从故障中恢复。假设我们通过让p在向任何其他处理器发送消息之前向其自己的磁盘写入来实现Disk Synod。这确保了它自己的磁盘在所有磁盘d中具有最大值disk[d][p].mbal。因此，在故障后重新启动，p只需要从自己的磁盘中读取其块。除了上述的mbal、bal和inp值之外，p还将在其磁盘上保留dblock[p]的值。

现在我们可以将这个算法与经典Paxos的Synod协议进行比较。dblock[p]的mbal、bal和inp组件只是Synod协议的lastTried[p]、nextBal[p]和prevVote[p]。Disk Synod算法的阶段1对应于Synod协议中发送NextBallot消息并接收LastVote响应。阶段2对应于发送BeginBallot并接收Voted回复。Synod协议的Success消息对应于上面提到的记录在磁盘上一个值已经被提交的优化。

这个版本的Disk Synod算法与Synod协议有两个不同之处。首先，Synod协议的NextBallot消息只包含mbal值；它不包含bal和inp值。为了获得Synod协议，我们必须修改Disk Synod算法，使得在阶段1中，它仅写入其磁盘块的mbal字段，并保持bal和inp字段不变。在这种修改下，算法保持正确，其基本相同的证明。然而，这种修改使得算法在实际磁盘上实现更加困难。

Disk Synod算法与Synod协议的第二个区别在于重新启动过程。磁盘仅包含上述的mbal、bal和inp值。它不包含其所有者的dblock值的单独副本。可以从以下变体的Disk Synod算法获得Synod协议。让bk是由处理器p在重新启动过程中读取的具有最大bal字段的块disk[d][p]。处理器p可以从任何磁盘块bk0开始阶段1，该磁盘块由任何处理器写入，使得bk0.bal ≥ bk.bal。可以证明，在此修改下，Disk Synod算法仍然是正确的。
## 4 总结
### 4.1 实现考虑
在我们对Disk Synod算法的描述中，隐含着一些关于在通过网络访问磁盘时如何实现读写的假设。如果发送到磁盘的操作可能丢失，那么处理器p必须从磁盘d接收一个确认，以确保其对disk[d][p]的写操作成功。这可能需要p在写入后显式地读取其磁盘块。如果操作可能以不同于发送顺序的顺序到达磁盘，那么p将不得不等待其对磁盘d的写操作成功的确认，然后才能从d读取其他处理器的块。此外，还需要一些机制来确保来自先前选票的写入不会在后续选票的写入之后到达同一处理器，从而用先前的值覆盖后来的值。如何实现这一点将取决于系统。（如果写入磁盘的操作可以在网络中任意长时间滞留并导致后续的值被覆盖，那么任何容错系统都无法实现。）

在Disk Paxos中，使用Disk Synod算法的一系列实例来提交一系列命令。在Disk Paxos的直接实现中，处理器p将向其磁盘块写入当前Disk Synod实例的dblock[p]的值，以及已经提交的所有命令的序列。已经提交的所有命令序列可能太大而无法放入单个磁盘块中。然而，完整的序列可以存储在多个磁盘块上。必须与dblock[p]保持在同一个磁盘块中的是指向队列头的指针。对于大多数应用程序来说，不需要记住整个命令序列。在许多情况下，必须保留的所有数据都可以放入单个磁盘块中。
在Disk Paxos被设计出来的应用程序（未来康柏的产品）中，处理器集合事先未知。每个磁盘包含一个列出处理器及其磁盘块位置的目录。在读取磁盘之前，处理器会先读取磁盘的目录。要写入磁盘的目录，处理器必须通过执行基于Fischer协议的实时互斥算法来获取该磁盘的锁。处理器通过在大多数磁盘上将自己添加到目录中来加入系统。

### 4.2 结束语

我们介绍了Disk Paxos，这是一种在处理器通过访问普通（非可编程）磁盘进行通信的系统中实现状态机方法的高效方法。在正常情况下，领导者通过在自己的块上写入数据，并在大多数共享磁盘上读取每个其他处理器的块来提交一个命令。这显然是一种共识算法所需的最小磁盘访问次数，即使是在少数磁盘或任一单个处理器失败的情况下，也能够取得进展。Disk Paxos的动机来自存储区域网络（SAN）的最新发展——这是一种由计算机和磁盘组成的架构，其中每台计算机都可以访问所有磁盘。商品磁盘比计算机更便宜，因此使用冗余磁盘进行容错比使用冗余计算机更经济。此外，由于磁盘不运行应用程序级别的程序，它们比计算机更不容易崩溃。
由于商品磁盘不可编程，我们不能简单地在经典Paxos算法中用磁盘替换处理器。相反，我们采用了经典Paxos的思想，并将其移植到SAN环境中。我们得到的几乎是经典Paxos的一种概括，但不完全是。实际上，当将Disk Paxos实例化为单个磁盘时，我们得到了可以称为共享内存Paxos的东西。共享内存的算法通常比它们的消息传递对应算法更简洁和清晰。因此，对于单个磁盘的Disk Paxos可以被认为是对经典Paxos的又一次重新审视，通过消除消息传递的混乱来暴露其基本思想。也许其他分布式算法也可以通过将它们重新构造为共享内存设置来变得更加清晰。