# Disk Paxos
## 3 Disk Synod的非正式描述
我们现在非正式地描述Disk Synod算法，并解释为什么它有效。我们还讨论了它与经典Paxos的Synod协议之间的关系。请记住，在正常操作中，只有一个领导者会执行该算法。其他处理器什么也不做；它们只是等待领导者告知它们结果。然而，即使在由多个处理器执行或当领导者在宣布结果之前失败并选择了新领导者的情况下，该算法也必须保持一致性。
### 3.1 算法
我们假设每个处理器p从一个输入值input[p]开始。就像Paxos的Synod算法一样，处理器执行一系列编号的选票，选票编号逐渐增加。选票号是一个正整数，并且不同的处理器使用不同的选票号。例如，如果处理器从1到N编号，那么处理器i可以使用选票号i，i + N，i + 2N等。处理器p执行选票分为两个阶段，第一个阶段试图选择一个值，第二个阶段试图提交该值。

在从第一阶段到第二阶段的过渡中发生了值v的选择。当处理器p完成第二阶段时，该值被提交，并可以输出。在任一阶段，如果处理器发现另一个处理器已经开始了一个更高编号的选票，它将中止其选票。在这种情况下，处理器可能会选择一个更高的选票号并开始一个新的选票。（如果它仍然认为自己是领导者，则会这样做。）如果处理器完成第二阶段而没有中止——也就是说，没有发现更高编号的选票——那么值v就会被提交，处理器可以输出它。处理器p在进入第二阶段之前不需要知道input[p]的值，因此可以提前对算法的任意数量的独立实例执行第一阶段。

为了确保一致性，我们必须保证两个不同的值不能成功提交——要么是由不同的处理器提交（因为领导者选举算法尚未成功），要么是由同一处理器在两个不同的选票中提交（因为它失败并重新开始）。为了确保算法是非阻塞的，我们必须保证如果只有一个处理器p在执行，那么p最终会提交一个值。
在实践中，当一个处理器成功提交一个值时，它将在其磁盘块上写入该值已被提交的信息，并将此事实广播给其他处理器。如果一个处理器得知某个值已经被提交，它将中止其选票并简单地输出该值。这个优化显然保持了正确性；我们不会进一步考虑它。
为了执行该算法，处理器p维护一个记录dblock[p]，其中包含以下三个组件：
- mbal：当前的选票号。
- bal：处理器p进入第二阶段的最大选票号。
- inp：处理器p在选票号bal中尝试提交的值。

初始时，bal等于0，inp等于一个特殊值NotAnInput，它不是可能的输入值，而mbal可以是其可能的任意选票号。我们将disk[d][p]定义为处理器p写入dblock[p]的磁盘d中的块。我们假设读取和写入一个块是原子操作。
处理器p执行选票的第1或第2阶段如下。对于每个磁盘d，它首先尝试将dblock[p]写入disk[d][p]，然后对所有其他处理器q读取disk[d][q]。如果对于任何d和q，它发现disk[d][q].mbal > dblock[p].mbal，则中止选票。当p已经写入并读取了大多数磁盘时，不读取任何mbal组件大于dblock[p].mbal的块，阶段就会完成。当它完成第1阶段时，p选择一个新值dblock[p].inp，将dblock[p].bal设置为dblock[p].mbal（其当前选票号），并开始第2阶段。当它完成第2阶段时，p已经提交了dblock[p].inp。

为了完成我们对两个阶段的描述，我们现在描述处理器p如何选择在第2阶段尝试提交的dblock[p].inp的值。让blocksSeen是由dblock[p]和处理器p在第1阶段读取的所有记录disk[d][q]组成的集合。让nonInitBlks是blocksSeen的子集，由那些inp字段不是NotAnInput的记录组成。如果nonInitBlks为空，则p将dblock[p].inp设置为其自己的输入值input[p]。否则，它将dblock[p].inp设置为nonInitBlks中具有最大值bk.bal的某个记录bk的inp。

最后，我们描述处理器p在从故障中恢复时做什么。在这种情况下，p从大多数磁盘d中读取其自己的块disk[d][p]。然后，它将dblock[p]设置为它读取的具有最大值bk.mbal的任何块bk，并通过增加dblock[p].mbal并开始第1阶段来开始一个新的选票。

该算法在图1中非正式地总结了处理器p执行单个选票的过程。处理器通过执行“开始选票”操作开始选票。如果选票中止，或在任何其他时候（除非它已失败，在这种情况下它必须执行“故障后重新启动”操作），它可以开始一个新的选票。算法的精确定义出现在附录中。